#!/bin/bash
set -e
# This entrypoint for KVM container configures and attaches network bridges to
# the VM and starts KVM with the selected options.

# See Dockerfile reference and README.md for further info.

: ${LAUNCHER:='qemu-system-x86_64'}
: ${DNSMASQ_CONF_DIR:='/etc/dnsmasq.d'}
: ${DNSMASQ:='/usr/sbin/dnsmasq'}
: ${QEMU_CONF_DIR:='/etc/qemu-kvm'}
: ${DISABLE_VGA:='Y'}

: ${CPU:='host'}
: ${THREADS:='1'}
: ${CORES:='1'}
: ${RAM:='2048'}

: ${DISK_SIZE:='16'}
: ${DISK_FORMAT:='qcow2'}
: ${DISK_CACHE:='none'}
: ${DISK_OPT_DRV:='cache=writeback,discard=on,aio=threads,detect-zeroes=on'}
: ${DISK_OPT_DEV:='rotation_rate=1'}
: ${DISK_PATH:='/image'}

: ${VM_IP:="20.20.20.21"}
: ${VM_MAC:="00:11:32:2C:A7:85"}

: ${VM_ENABLE_VIRTIO:="Y"}
: ${VM_ENABLE_VIRTIO_SCSI:="N"}
: ${VM_ENABLE_9P:="Y"}
: ${VM_ENABLE_VGA:="N"}

: ${VM_PATH_9P:=''}
: ${VM_CUSTOM_OPTS:=''}

: ${BOOTLOADER_URL:='http://host/path/bootloader.img'}
: ${BOOTLOADER_AS_USB:='Y'}

: ${GRUBCFG_VID:='46f4'}
: ${GRUBCFG_PID:='0001'}
: ${GRUBCFG_SN:=''}
: ${GRUBCFG_MAC1:=''}
: ${GRUBCFG_DISKIDXMAP:=''}
: ${GRUBCFG_SATAPORTMAP:=''}
: ${GRUBCFG_DISKIDXMAP:=''}



: ${DEBUG:='Y'}


# Functions
# ######################################

log () {
  case "$1" in
    INFO | WARNING | ERROR )
      echo "$1: ${@:2}"
      ;;
    DEBUG)
      if [[ "$DEBUG" == [Yy1]* ]]; then
          echo "$1: ${@:2}"
      fi
      ;;
    *)
      echo "-- $@"
      ;;
  esac
}

setupDhcp () {
  CIDR="24"
  MAC="$1"
  IP="$2"
  #HOSTNAME=$(hostname -s)
  HOSTNAME="VirtualMachine"
  # dnsmasq configuration:
  log "INFO" "DHCP configured to serve IP $IP/$CIDR via dockerbridge"
  DNSMASQ_OPTS="$DNSMASQ_OPTS --dhcp-range=$IP,$IP --dhcp-host=$MAC,,$IP,$HOSTNAME,infinite --dhcp-option=option:netmask,255.255.255.0"
  # Create lease File FOr faster resolve
  echo "0 $MAC $IP $HOSTNAME 01:${MAC}" > /var/lib/misc/dnsmasq.leases
  chmod 644 /var/lib/misc/dnsmasq.leases
}

# Setup macvtap device to connect later the VM and setup a new macvlan devide
# to connect the host machine to the network
configureNetworks () {
  #For now we define static MAC because DHCP is very slow if MAC change every VM Boot
  #Create bridge with static IP for the VM Guest(COnnection VM-Docker)
  brctl addbr dockerbridge
  ip addr add ${VM_IP%.*}.1/24 broadcast ${VM_IP%.*}.255 dev dockerbridge
  ip link set dockerbridge up
  #QEMU Works with taps, set tap to the bridge created
  ip tuntap add dev vm-nat mode tap
  ip link set vm-nat up promisc on
  brctl addif dockerbridge vm-nat

  #Add internet connection to the VM
  iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
  iptables -t nat -A PREROUTING -i eth0 -p tcp  -j DNAT --to $VM_IP
  iptables -t nat -A PREROUTING -i eth0 -p udp  -j DNAT --to $VM_IP
  
  #Enable port forwarding flag
  sysctl -w net.ipv4.ip_forward=1
  
  #For now we define static MAC because DHCP is very slow if DHCP change every VM Boot
  setupDhcp $VM_MAC $VM_IP
}

ddReplaceInFile () {
	_tmpFile="$1"
	_tmpSearch="$2"
	_tmpReplace="$3"
	
	_tmpStr="${_tmpSearch}${_tmpReplace}"
	_tmpRes="$( grep -oba "${_tmpSearch}[[:alnum:]]\{${#_tmpReplace}\}" ${_tmpFile} )"
	
	log "INFO" "ddReplace for: ${_tmpStr}"
	
	if [[ "x${_tmpRes}" != "x" ]]; then
		for i in ${_tmpRes}; do
			_tmpCnt="$( printf ${i#*:} | wc -c )"
			[[ ${#_tmpStr} -ne ${_tmpCnt} ]] && log "WARNING" "... Nb of char is not equal: ${#_tmpStr} =/= ${i#*:}" && continue
			printf "%-${_tmpCnt}s" "${_tmpStr}" | dd of=${_tmpFile} conv=notrunc bs=1 seek=${i%:*} count=${_tmpCnt} >/dev/null 2>&1
			[[ $( grep -oba "${_tmpStr}" ${_tmpFile} | wc -l ) -gt 0 ]] \
				&& log "INFO" "... Successful replacement of: ${i#*:}" \
				|| log "WARNING" "... Unsuccessful: Reason unknown!"
		done
	else
		log "WARNING" "... ${_tmpSearch} not found!"
	fi
}

# ######################################
# ######################################
# 				MAIN 
# ######################################
# ######################################

log "INFO" "Xpenology docker is starting ..."

mkdir -p ${DISK_PATH}

# Download and check synoboot bootloader
# ######################################

BOOTLOADER_FULLPATH="${DISK_PATH%/}/bootloader.img"
BOOTLOADER_BAK_EXT=".tar.gz"

flag_bootl_err=0
if [[ -f ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} ]] ; then
	log "INFO" "Skip URL download, raw bootloader already exist: ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} ."
	log "INFO" "${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} exists, skipping grub.cfg modification"
	flag_bootl_err=1
elif [[ -f ${BOOTLOADER_FULLPATH} ]] ; then
	log "INFO" "Skip URL download, raw bootloader already exist: ${BOOTLOADER_FULLPATH} ."
else
	log "INFO" "Start downloading bootloader from URL: ${BOOTLOADER_URL} ..."
	wget --no-check-certificate -q --show-progress --progress=dot:giga ${BOOTLOADER_URL} -O ${BOOTLOADER_FULLPATH}.tmp \
		&& echo "" && log "INFO" "Bootloader has been successfully downloaded from URL." \
		|| ( log "ERROR" "Bootloader cannot be downloaded from URL." && rm -f ${BOOTLOADER_FULLPATH}.tmp* && exit 10 )

	if [[ $( file ${BOOTLOADER_FULLPATH}.tmp | grep -c ": gzip" ) -eq 1 ]]; then
		log "INFO" "Downloaded file is detected as gzip file, extracting ..."
		tar -xzOf ${BOOTLOADER_FULLPATH}.tmp $( tar -tzf ${BOOTLOADER_FULLPATH}.tmp | head -1 ) > ${BOOTLOADER_FULLPATH}.tmp2
	elif [[ $( file ${BOOTLOADER_FULLPATH}.tmp | grep -c ": Zip" ) -eq 1 ]]; then
		log "INFO" "Downloaded file is detected as zip file, extracting ..."
		unzip -p ${BOOTLOADER_FULLPATH}.tmp $( unzip -l ${BOOTLOADER_FULLPATH}.tmp | head -4 | tail -1 | awk '{print $4}' ) > ${BOOTLOADER_FULLPATH}.tmp2
	fi
	
	[[ -f ${BOOTLOADER_FULLPATH}.tmp2 ]] && mv -f ${BOOTLOADER_FULLPATH}.tmp2 ${BOOTLOADER_FULLPATH}.tmp
	
	[[ $( file ${BOOTLOADER_FULLPATH}.tmp | grep -c "boot sector" ) -eq 1 ]] \
		&& log "INFO" "Downloaded file seems bootable! Good good!" \
		&& mv ${BOOTLOADER_FULLPATH}.tmp ${BOOTLOADER_FULLPATH} \
		|| ( log "ERROR" "Downloaded file is not bootable!" && rm -f ${BOOTLOADER_FULLPATH}.tmp* && exit 11 )
fi

[[ $( ls -l ${BOOTLOADER_FULLPATH}.tmp* 2>/dev/null | wc -l ) -ne 0 ]] && rm -f ${BOOTLOADER_FULLPATH}.tmp*


# grub.cfg modification
if [[ $flag_bootl_err -eq 0 ]]; then
	log "INFO" "Backing up bootloader: ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT}"
	tar -czf ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} -C ${BOOTLOADER_FULLPATH%/*} ${BOOTLOADER_FULLPATH##*/} 
	
	log "INFO" "Modification of grub.cfg ..."
	
	[[ "x${GRUBCFG_VID}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "vid=0x" ${GRUBCFG_VID}
	[[ "x${GRUBCFG_PID}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "pid=0x" ${GRUBCFG_PID}
	
	[[ "x${GRUBCFG_SN}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "sn=" ${GRUBCFG_SN}
	
	GRUBCFG_MAC1="$( echo ${VM_MAC} | tr -cd '[:alnum:]' | tr '[:lower:]' '[:upper:]' )"
	[[ "x${GRUBCFG_MAC1}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "mac1=" ${GRUBCFG_MAC1}
	
	[[ "x${GRUBCFG_DISKIDXMAP}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "DiskIdxMap=" ${GRUBCFG_DISKIDXMAP}
	[[ "x${GRUBCFG_SATAPORTMAP}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "SataPortMap=" ${GRUBCFG_SATAPORTMAP}
	[[ "x${GRUBCFG_SASIDXMAP}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "SasIdxMap=" ${GRUBCFG_SASIDXMAP}
fi



# Convert bootloader to other format (only qcow2 for now)
if [[ ${DISK_FORMAT} == "qcow2" ]]; then
	if [[ ! -f ${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT} ]]; then
		qemu-img convert -f raw -O ${DISK_FORMAT} ${BOOTLOADER_FULLPATH} ${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT} \
			&& log "INFO" "Bootloader has been converted to ${DISK_FORMAT}" \
			|| ( log "ERROR" "Cannot convert Bootloader to ${DISK_FORMAT}. Exiting." && exit 20 )
	else
		log "INFO" "Skip bootloader ${DISK_FORMAT} convertion, because it already exist."
	fi
	
	# delete img bootloader if bak exist
	[[ -f ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} ]] \
		&& rm -f ${BOOTLOADER_FULLPATH}

	BOOTLOADER_FULLPATH=${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT}
elif [[ ! -f ${BOOTLOADER_FULLPATH} ]]; then
	log "INFO" "... copy/extract bak to ${BOOTLOADER_FULLPATH}"
	tar -xzf ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} -C ${BOOTLOADER_FULLPATH%/*}
fi

# Set 1st disk for snapshot
# ######################################
i_sata=0
: ${KVM_PREBOOT:=""}
KVM_PREBOOT="${KVM_PREBOOT} -device 'ahci,id=ahci0,multifunction=on,bus=pci.0,addr=0x7'"
if [[ ${DISK_FORMAT} == "qcow2" ]]; then
	log "INFO" "Adding snapshot disk ... "
	fpath_diskname_="${DISK_PATH%/}/vm-disk-snapshot.${DISK_FORMAT}"
	[[ ! -f ${fpath_diskname_} ]] \
		&& qemu-img create -f ${DISK_FORMAT} ${fpath_diskname_} 8M \
		&& log "INFO" "... new snapshot disk created" \
		|| log "INFO" "... SKIP: snapshot disk already exists"
	KVM_PREBOOT="${KVM_PREBOOT} -drive 'file=${fpath_diskname_},if=none,id=drive-disk-snap,format=${DISK_FORMAT},${DISK_OPT_DRV}'"
	if [[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]]; then
		KVM_PREBOOT="${KVM_PREBOOT} -device 'virtio-blk-pci,drive=drive-disk-snap,id=virtio-disk-snap,bus=pci.0,addr=0xa'"
	else
		KVM_PREBOOT="${KVM_PREBOOT} -device 'ide-hd,bus=ahci0.${i_sata},drive=drive-snap,id=sata-disk-snap'"
		((++i_sata))
	fi
fi

# Set bootloader as USB or as SATA disk
# ######################################
log "INFO" "Adding bootloader as $([[ ${BOOTLOADER_AS_USB} == [Yy1]* ]] && echo "USB" || echo "SATA") ..."
KVM_SYNOBOOT="${KVM_SYNOBOOT} -device 'nec-usb-xhci,id=usb-bus0,multifunction=on'"
KVM_SYNOBOOT="${KVM_SYNOBOOT} -drive 'file=${BOOTLOADER_FULLPATH},format=${BOOTLOADER_FULLPATH##*.},if=none,id=drive-disk-bootloader,cache=${DISK_CACHE},aio=native,detect-zeroes=on'"

if [[ "${BOOTLOADER_AS_USB}" == [Yy1]* ]]; then
	KVM_SYNOBOOT="${KVM_SYNOBOOT} -device 'usb-storage,bus=usb-bus0.0,port=1,drive=drive-disk-bootloader,id=usb-disk-bootloader,bootindex=1,removable=on'"
else
	# Use bootloader as first sata disk
	KVM_SYNOBOOT="${KVM_SYNOBOOT} -device 'ide-hd,bus=ahci0.${i_sata},drive=drive-disk-bootloader,id=sata-disk-bootloader,bootindex=1'"
	((++i_sata))
fi

# Add SATA disks
# ######################################
log "INFO" "Adding disk(s)  ..."
TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS}"
fpath_diskname_=""
diskformat_=""

i_scsi=0
if [[ "${VM_ENABLE_VIRTIO_SCSI}" == [Yy1]* ]]; then
 #TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -iscsi 'initiator-name=iqn.1993-08.org.debian:01:c9fc21d990e0'"
 TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'virtio-scsi-pci,id=scsihw0,bus=pcie.0,addr=0x10,num_queues=4'"
fi

i=0
for size in $DISK_SIZE ; do
	if [[ $size == "/dev/"* ]] && [[ -e "$size" ]]; then
		log "INFO" "... adding full device : $size"
		fpath_diskname_="$size"
		diskformat_="raw"
	elif [[ ${size%[Gg]} =~ ^[0-9]+$ ]]; then
		diskformat_="${DISK_FORMAT}"
		fpath_diskname_="${DISK_PATH%/}/vm-disk-data${i}.${diskformat_}"
		if [[ ! -f ${fpath_diskname_} ]]; then
			log "INFO" "... No Initial Disk found, creating disk : ${fpath_diskname_}"
			qemu-img create -f ${DISK_FORMAT} ${fpath_diskname_} ${size%[Gg]}G \
				|| (log "ERROR" "... FAILED creating disk : ${fpath_diskname_}" && exit 13)
		else
			log "INFO" "... Disk already exists, SKIP creating disk : ${fpath_diskname_}"
		fi
		((++i))
	else
		log "WARNING" "... invalid argument : $size"	
		continue
	fi
	
	if [[ "${VM_ENABLE_VIRTIO_SCSI}" == [Yy1]* ]]; then
		#TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'virtio-scsi-pci,id=scsihw${i_scsi},bus=pcie.0,addr=0x$(( i_scsi+10 ))'"
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -drive 'file=${fpath_diskname_},if=none,id=drive-scsi${i_scsi},format=${diskformat_},${DISK_OPT_DRV}'"
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=${i_scsi},drive=drive-scsi${i_scsi},id=scsi${i_scsi},${DISK_OPT_DEV}'"
		# TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'nvme,drive=drive-scsi${i_scsi},serial=nvme-${i_scsi},id=nvme${i_scsi}'"
		# serial=VH000${i_scsi}
		((++i_scsi))
	else
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -drive 'file=${fpath_diskname_},if=none,id=drive-sata${i_sata},format=${diskformat_},${DISK_OPT_DRV}'"
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'ide-hd,bus=ahci0.${i_sata},drive=drive-sata${i_sata},id=sata${i_sata},${DISK_OPT_DEV}'"
		((++i_sata))
	fi
done
: ${KVM_BLK_OPTS:="${TMP_KVM_BLK_OPTS}"}

# Set Qemu option
# ######################################
: ${KVM_OPTS:="\
  -machine q35 \
  -readconfig /qemu_cfg/pve-q35-4.0.cfg \
  -nodefaults \
  -overcommit mem-lock=off \
  -msg timestamp=on \
  -chardev pty,id=charserial0 \
  -device isa-serial,chardev=charserial0,id=serial0 \
  -serial stdio \
  -monitor unix:/run/qemu-monitor.sock,server,nowait \
  -pidfile /run/qemu.pid \
  "}

[[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]] && KVM_OPTS="${KVM_OPTS} -device 'virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3'"

# Set Qemu CPU and RAM
# ######################################
SMP=$(($CORES*$THREADS))
: ${KVM_CPU_OPTS:="-m $RAM -cpu ${CPU} -smp $SMP,sockets=1,cores=$CORES,threads=$THREADS"}

# Set 9p
# ######################################
: ${KVM_9P:=""}
if [[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]] && [[ "${VM_ENABLE_9P}" == [Yy1]* ]] && [[ "x${VM_PATH_9P}" != "x" ]]; then 
	log "INFO" "Adding 9p sharefolders ..."

	i=0
	for path_ in $VM_PATH_9P ; do
		log "INFO" "... path=${path_} , mount_tag=hostdata${i}"
		KVM_9P="${KVM_9P} -fsdev local,security_model=passthrough,id=fsdev-fs${i},path=${path_} -device virtio-9p-pci,id=fs${i},fsdev=fsdev-fs${i},mount_tag=hostdata${i},bus=pcie.0"
		((++i))
	done
fi

# Enable KVM support only if the host supports it
# ######################################
if [[ $(grep -e vmx -e svm /proc/cpuinfo) ]]; then
  log "INFO" "KVM acceleration enabled"
  KVM_OPTS="$KVM_OPTS -enable-kvm -machine accel=kvm,usb=off "
else
  log "WARNING" "KVM acceleration disabled"
  #exit -20
fi

# Set Qemu graphics & vnc 
# ######################################
if [[ "$VM_ENABLE_VGA" == [Yy1]* ]]; then
  : ${KVM_VIDEO_OPTS:="-vga qxl -vnc 0.0.0.0:0 -k en-us"}
else
  : ${KVM_VIDEO_OPTS:="-nographic"}
fi

# Configure Network
# ######################################
log "INFO" "Configuring network ..."
DEFAULT_ROUTE=$(ip route | grep default | awk '{print $3}')

configureNetworks
KVM_NET_OPTS="-netdev tap,ifname=vm-nat,script=no,downscript=no,id=hostnet0"
#KVM_NET_OPTS="-netdev tap,vhost=on,id=hostnet0,fd=3 3<>/dev/vm-nat"
#KVM_NET_OPTS="-netdev user,hostfwd=tcp:127.0.0.1:5000-:5000"
[[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]] \
	&& KVM_NET_OPTS="${KVM_NET_OPTS} -device virtio-net-pci,netdev=hostnet0,mac=$VM_MAC,id=net0" \
	|| KVM_NET_OPTS="${KVM_NET_OPTS} -device e1000,netdev=hostnet0,mac=$VM_MAC,id=net0"


# Hack for guest VMs complaining about "bad udp checksums in 5 packets"
log "INFO" "Hack for guest VMs complaining about: bad udp checksums in 5 packets"
iptables -A POSTROUTING -t mangle -p udp --dport bootpc -j CHECKSUM --checksum-fill \
        || ( log "WARNING" "Iptables hack for checksum FAILED" && ethtool -K eth0 tx off || true )


# Build DNS options from container /etc/resolv.conf
nameservers=($(grep '^nameserver' /etc/resolv.conf | sed 's/nameserver //'))
searchdomains=$(grep '^search' /etc/resolv.conf | sed 's/search //' | sed 's/ /,/g')
domainname=$(echo $searchdomains | awk -F"," '{print $1}')

for nameserver in "${nameservers[@]}"; do
  [[ -z $DNS_SERVERS ]] && DNS_SERVERS=$nameserver || DNS_SERVERS="$DNS_SERVERS,$nameserver"
done
DNSMASQ_OPTS="$DNSMASQ_OPTS                         \
  --dhcp-option=option:dns-server,$DNS_SERVERS      \
  --dhcp-option=option:router,${VM_IP%.*}.1         \
  --dhcp-option=option:domain-search,$searchdomains \
  --dhcp-option=option:domain-name,$domainname      \
  "
[[ -z $(hostname -d) ]] || DNSMASQ_OPTS="$DNSMASQ_OPTS --dhcp-option=option:domain-name,$(hostname -d)"

log "INFO" "Lauching dnsmasq"
log "DEBUG" "dnsmasq options: $DNSMASQ_OPTS"
$DNSMASQ $DNSMASQ_OPTS


# Launching Qemu VM command
# ######################################
log "INFO" "Launching qemu-kvm ..."
COMMAND="$LAUNCHER $KVM_OPTS ${KVM_PREBOOT} $KVM_SYNOBOOT $KVM_BLK_OPTS $KVM_VIDEO_OPTS $KVM_CPU_OPTS $KVM_NET_OPTS $KVM_9P $VM_CUSTOM_OPTS $@"
log "DEBUG" "${COMMAND}"
trap '/usr/bin/vm-power-down' SIGTERM
trap '/usr/bin/vm-power-down' SIGINT
eval exec ${COMMAND}
