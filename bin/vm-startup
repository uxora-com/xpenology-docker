#!/bin/bash
set -e
mkdir -p ${DISK_PATH}/log ${VM_9P_PATH}
exec &> >(tee -a ${DISK_PATH}/log/xpenodock$(date "+_%Y%m%d_%H%M%S").log)

# This entrypoint for KVM container configures and attaches network bridges to
# the VM and starts KVM with the selected options.

# See Dockerfile reference and README.md for further info.

: ${LAUNCHER:='qemu-system-x86_64'}
: ${DNSMASQ_CONF_DIR:='/etc/dnsmasq.d'}
: ${DNSMASQ:='/usr/sbin/dnsmasq'}
: ${QEMU_CONF_DIR:='/etc/qemu-kvm'}
: ${DISABLE_VGA:='Y'}

: ${CPU:='qemu64'}
: ${THREADS:='1'}
: ${CORES:='1'}
: ${RAM:='2048'}

: ${DISK_SIZE:='16'}
: ${DISK_FORMAT:='qcow2'}
: ${DISK_OPTS_DRV:='cache=writeback,discard=on,aio=threads,detect-zeroes=on'}
: ${DISK_OPTS_DEV:='rotation_rate=1'}
: ${DISK_PATH:='/xpy/diskvm'}

: ${VM_NET_TAP:=""}
: ${VM_NET_IP:="20.20.20.21"}
: ${VM_NET_MAC:="00:11:32:2C:A7:85"}
: ${VM_NET_DHCP:="N"}

: ${VM_ENABLE_VIRTIO:="Y"}
: ${VM_ENABLE_VIRTIO_SCSI:="N"}
: ${VM_ENABLE_9P:="N"}
: ${VM_ENABLE_VGA:="N"}

: ${VM_9P_PATH:=''}
: ${VM_9P_OPTS:='local,security_model=passthrough'}

: ${BOOTLOADER_URL:='http://host/path/bootloader.img'}
: ${BOOTLOADER_AS_USB:='Y'}

: ${GRUBCFG_AUTO:='Y'}
: ${GRUBCFG_VID:=''}
: ${GRUBCFG_PID:=''}
: ${GRUBCFG_SN:=''}
: ${GRUBCFG_DISKIDXMAP:=''}
: ${GRUBCFG_SATAPORTMAP:=''}
: ${GRUBCFG_SASIDXMAP:=''}
: ${GRUBCFG_HDDHOTPLUG:=''}
: ${GRUBCFG_MAC1:=''}

: ${VM_CUSTOM_OPTS:=''}
: ${VM_CUSTOM_CODE:=''}
: ${VM_CUSTOM_BOOTWAIT:='10'}

: ${DEBUG:='Y'}


# Functions
# ######################################

log () {
  case "$1" in
    INFO | WARNING | ERROR )
      echo "$1: ${@:2}"
      ;;
    DEBUG)
      if [[ "$DEBUG" == [Yy1]* ]]; then
          echo "$1: ${@:2}"
      fi
      ;;
    *)
      echo "-- $@"
      ;;
  esac
}

setupLocalDhcp () {
  CIDR="24"
  MAC="$1"
  IP="$2"
  #HOSTNAME=$(hostname -s)
  HOSTNAME="VirtualMachine"
  # dnsmasq configuration:
  log "INFO" "DHCP configured to serve IP $IP/$CIDR via dockerbridge"
  DNSMASQ_OPTS="$DNSMASQ_OPTS --dhcp-range=$IP,$IP --dhcp-host=$MAC,,$IP,$HOSTNAME,infinite --dhcp-option=option:netmask,255.255.255.0"
  # Create lease File FOr faster resolve
  echo "0 $MAC $IP $HOSTNAME 01:${MAC}" > /var/lib/misc/dnsmasq.leases
  chmod 644 /var/lib/misc/dnsmasq.leases
}

# Setup macvtap device to connect later the VM and setup a new macvlan devide
# to connect the host machine to the network
configureNatNetworks () {
  #For now we define static MAC because DHCP is very slow if MAC change every VM Boot
  #Create bridge with static IP for the VM Guest(COnnection VM-Docker)
  brctl addbr dockerbridge
  ip addr add ${VM_NET_IP%.*}.1/24 broadcast ${VM_NET_IP%.*}.255 dev dockerbridge
  ip link set dockerbridge up
  #QEMU Works with taps, set tap to the bridge created
  ip tuntap add dev ${VM_NET_TAP} mode tap
  ip link set ${VM_NET_TAP} up promisc on
  brctl addif dockerbridge ${VM_NET_TAP}

  #Add internet connection to the VM
  iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
  iptables -t nat -A PREROUTING -i eth0 -p tcp  -j DNAT --to $VM_NET_IP
  iptables -t nat -A PREROUTING -i eth0 -p udp  -j DNAT --to $VM_NET_IP
  
  #Enable port forwarding flag
  [[ $(< /proc/sys/net/ipv4/ip_forward) -eq 0 ]] && sysctl -w net.ipv4.ip_forward=1
  
  #For now we define static MAC because DHCP is very slow if DHCP change every VM Boot
  setupLocalDhcp $VM_NET_MAC $VM_NET_IP
}

ddReplaceInFile () {
	_tmpFile="$1"
	_tmpSearch="$2"
	_tmpReplace="$3"
	_tmpMode="$4"
	
	_tmpStr="${_tmpSearch}${_tmpReplace}"
	
	[[ ${_tmpMode} -eq 0 ]] \
	  && _tmpRes="$( grep -oba "${_tmpSearch}[[:alnum:]]\{${#_tmpReplace}\}" ${_tmpFile} )" \
	  || _tmpRes="$( grep -oba "${_tmpSearch}[[:alnum:]]\+" ${_tmpFile} )"
	
	log "INFO" "ddReplace for: ${_tmpStr}"
	
	if [[ "x${_tmpRes}" != "x" ]]; then
		for i in ${_tmpRes}; do
			_tmpCnt="$( printf ${i#*:} | wc -c )"
			
			[[ ${_tmpMode} -eq 0 ]] && [[ ${#_tmpStr} -ne ${_tmpCnt} ]] \
				&& log "WARNING" "... Nb of char is not equal: ${#_tmpStr} =/= ${i#*:}" && continue
			
			[[ "x${_tmpStr}" == "x${i#*:}" ]] \
				&& log "INFO" "... No need to change: value is the same!" && continue
			
			printf "%-${_tmpCnt}s" "${_tmpStr}" | dd of=${_tmpFile} conv=notrunc bs=1 seek=${i%:*} count=${_tmpCnt} >/dev/null 2>&1
			
			[[ $( grep -oba "${_tmpStr}" ${_tmpFile} | wc -l ) -gt 0 ]] \
				&& log "INFO" "... Successful replacement of: ${i#*:}" \
				|| log "WARNING" "... Unsuccessful: Reason unknown!"
		done
	else
		log "WARNING" "... ${_tmpSearch} not found!"
	fi
}

# ######################################
# ######################################
# 				MAIN 
# ######################################
# ######################################

log "INFO" "Xpenology docker V${SCRIPT_VERSION} is starting [pid:${$}] ..."

# DEPRECATED
[[ "x${VM_PATH_9P}" != "x" ]] \
	&& log "ERROR" "VM_PATH_9P is deprecated! Use VM_9P_PATH instead." && exit 2
[[ "x${DISK_CACHE}" != "x" ]] \
	&& log "ERROR" "DISK_CACHE is deprecated! Use DISK_OPTS_DRV instead." && exit 3

# Patch
# ######################################
log "INFO" "Little dirty trick ..."
update-alternatives --set iptables /usr/sbin/iptables-legacy
update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy


if [[ "${GRUBCFG_AUTO}" == [Yy1]* ]] && [[ "x${GRUBCFG_VID}" == "x" ]] && [[ "x${GRUBCFG_PID}" == "x" ]]; then
	[[ "${BOOTLOADER_AS_USB}" == [Yy1]* ]] && GRUBCFG_VID='46f4' && GRUBCFG_PID='0001'
fi

[[ "${VM_ENABLE_VIRTIO_SCSI}" == [Yy1]* ]] && VM_ENABLE_VIRTIO="Y"
[[ "x${VM_9P_PATH}" != "x" ]] && VM_ENABLE_9P="Y"

[[ "x${DISK_OPTS_DRV}" != "x" ]] && DISK_OPTS_DRV=",${DISK_OPTS_DRV#,}"
[[ "x${DISK_OPTS_DEV}" != "x" ]] && DISK_OPTS_DEV=",${DISK_OPTS_DEV#,}"

# Download and check synoboot bootloader
# ######################################

BOOTLOADER_FULLPATH="${DISK_PATH%/}/bootloader.img"
BOOTLOADER_BAK_EXT=".tar.gz"

flag_bootl_err=0
if [[ -f ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} ]] ; then
	log "INFO" "SKIP download URL: gzip bootloader already exist: ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT}"
	log "INFO" "SKIP grub.cfg modification: gzip bootloader already exist: ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT}"
	flag_bootl_err=1
elif [[ -f ${BOOTLOADER_FULLPATH} ]] ; then
	log "INFO" "SKIP download URL: raw bootloader already exist: ${BOOTLOADER_FULLPATH}"
else
	log "INFO" "Start downloading bootloader from URL: ${BOOTLOADER_URL} ..."
	wget --no-check-certificate -q --show-progress --progress=dot:giga ${BOOTLOADER_URL} -O ${BOOTLOADER_FULLPATH}.tmp \
		&& echo "" && log "INFO" "... SUCCESS: file downloaded from URL." \
		|| ( log "ERROR" "... FAILED: file cannot be downloaded from URL." && rm -f ${BOOTLOADER_FULLPATH}.tmp* && exit 10 )

	if [[ $( file ${BOOTLOADER_FULLPATH}.tmp | grep -c ": gzip" ) -eq 1 ]]; then
		log "INFO" "Downloaded file is detected as gzip file, extracting ..."
		tar -xzOf ${BOOTLOADER_FULLPATH}.tmp $( tar -tzf ${BOOTLOADER_FULLPATH}.tmp | head -1 ) > ${BOOTLOADER_FULLPATH}.tmp2
	elif [[ $( file ${BOOTLOADER_FULLPATH}.tmp | grep -c ": Zip" ) -eq 1 ]]; then
		log "INFO" "Downloaded file is detected as zip file, extracting ..."
		unzip -p ${BOOTLOADER_FULLPATH}.tmp $( unzip -l ${BOOTLOADER_FULLPATH}.tmp | head -4 | tail -1 | awk '{print $4}' ) > ${BOOTLOADER_FULLPATH}.tmp2
	fi
	
	[[ -f ${BOOTLOADER_FULLPATH}.tmp2 ]] && mv -f ${BOOTLOADER_FULLPATH}.tmp2 ${BOOTLOADER_FULLPATH}.tmp
	
	[[ $( file ${BOOTLOADER_FULLPATH}.tmp | grep -c "boot sector" ) -eq 1 ]] \
		&& log "INFO" "Downloaded file seems bootable! Good good!" \
		&& mv ${BOOTLOADER_FULLPATH}.tmp ${BOOTLOADER_FULLPATH} \
		|| ( log "ERROR" "Downloaded file is not bootable!" && rm -f ${BOOTLOADER_FULLPATH}.tmp* && exit 11 )
fi

[[ $( ls -l ${BOOTLOADER_FULLPATH}.tmp* 2>/dev/null | wc -l ) -ne 0 ]] && rm -f ${BOOTLOADER_FULLPATH}.tmp*


# grub.cfg modification
if [[ $flag_bootl_err -eq 0 ]]; then
	log "INFO" "Backing up bootloader: ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT}"
	tar -czf ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} -C ${BOOTLOADER_FULLPATH%/*} ${BOOTLOADER_FULLPATH##*/} 
	
	log "INFO" "Modification of grub.cfg ..."
	
	[[ "x${GRUBCFG_VID}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "vid=0x" ${GRUBCFG_VID} 0
	[[ "x${GRUBCFG_PID}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "pid=0x" ${GRUBCFG_PID} 0
	
	[[ "x${GRUBCFG_SN}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "sn=" ${GRUBCFG_SN} 0
	
	GRUBCFG_MAC1="$( echo ${VM_NET_MAC} | tr -cd '[:alnum:]' | tr '[:lower:]' '[:upper:]' )"
	[[ "x${GRUBCFG_MAC1}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "mac1=" ${GRUBCFG_MAC1} 0
	
	[[ "x${GRUBCFG_DISKIDXMAP}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "DiskIdxMap=" ${GRUBCFG_DISKIDXMAP} 1
	[[ "x${GRUBCFG_SATAPORTMAP}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "SataPortMap=" ${GRUBCFG_SATAPORTMAP} 1
	[[ "x${GRUBCFG_SASIDXMAP}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "SasIdxMap=" ${GRUBCFG_SASIDXMAP} 1
	
	[[ "x${GRUBCFG_HDDHOTPLUG}" != "x" ]] && ddReplaceInFile ${BOOTLOADER_FULLPATH} "HddHotplug=" ${GRUBCFG_HDDHOTPLUG} 0
fi



# Convert bootloader to other format (only qcow2 for now)
if [[ ${DISK_FORMAT} == "qcow2" ]]; then
	log "INFO" "Bootloader convertion ..."
	if [[ ! -f ${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT} ]]; then
		qemu-img convert -f raw -O ${DISK_FORMAT} ${BOOTLOADER_FULLPATH} ${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT} \
			&& log "INFO" "... SUCCESS: Bootloader has been converted to ${DISK_FORMAT}: ${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT}" \
			|| ( log "ERROR" "... FAILED: Cannot convert Bootloader to ${DISK_FORMAT}. Exiting." && exit 20 )
	else
		log "INFO" "... SKIP: bootloader ${DISK_FORMAT} already exists: ${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT}"
	fi
	
	# delete img bootloader if bak exist
	[[ -f ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} ]] \
		&& rm -f ${BOOTLOADER_FULLPATH}

	BOOTLOADER_FULLPATH=${BOOTLOADER_FULLPATH%.img}.${DISK_FORMAT}
elif [[ ! -f ${BOOTLOADER_FULLPATH} ]]; then
	log "INFO" "... copy/extract bak to ${BOOTLOADER_FULLPATH}"
	tar -xzf ${BOOTLOADER_FULLPATH}${BOOTLOADER_BAK_EXT} -C ${BOOTLOADER_FULLPATH%/*}
fi

# Set 1st disk for snapshot
# ######################################
i_sata=0
: ${KVM_PREBOOT:=""}
KVM_PREBOOT="${KVM_PREBOOT} -device 'ahci,id=ahci0,multifunction=on,bus=pcie.0,addr=0x10'"
if [[ ${DISK_FORMAT} == "qcow2" ]]; then
	log "INFO" "Adding snapshot disk ... "
	fpath_diskname_="${DISK_PATH%/}/vm-disk-snapshot.${DISK_FORMAT}"
	if [[ ! -f ${fpath_diskname_} ]]; then
		qemu-img create -f ${DISK_FORMAT} ${fpath_diskname_} 8M \
		  && log "INFO" "... SUCCESS: snapshot disk created: ${fpath_diskname_}" \
		  || log "ERROR" "... FAILED: Cannot create snapshot disk"
	else
		log "INFO" "... SKIP: snapshot disk already exists: ${fpath_diskname_}"
	fi
	KVM_PREBOOT="${KVM_PREBOOT} -drive 'file=${fpath_diskname_},if=none,id=drive-disk-snap,format=${DISK_FORMAT}${DISK_OPTS_DRV}'"
	if [[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]]; then
		KVM_PREBOOT="${KVM_PREBOOT} -device 'virtio-blk-pci,drive=drive-disk-snap,id=virtio-disk-snap,bus=pcie.0,addr=0x4'"
	else
		KVM_PREBOOT="${KVM_PREBOOT} -device 'ide-hd,bus=ahci0.${i_sata},drive=drive-disk-snap,id=sata-disk-snap'"
		((++i_sata))
	fi
fi

# Set bootloader as USB or as SATA disk
# ######################################
log "INFO" "Adding bootloader as $([[ ${BOOTLOADER_AS_USB} == [Yy1]* ]] && echo "USB" || echo "SATA") ..."
KVM_SYNOBOOT="${KVM_SYNOBOOT} -device 'nec-usb-xhci,id=usb-bus0,multifunction=on'"
KVM_SYNOBOOT="${KVM_SYNOBOOT} -drive 'file=${BOOTLOADER_FULLPATH},format=${BOOTLOADER_FULLPATH##*.},if=none,id=drive-disk-bootloader${DISK_OPTS_DRV}'"

if [[ "${BOOTLOADER_AS_USB}" == [Yy1]* ]]; then
	KVM_SYNOBOOT="${KVM_SYNOBOOT} -device 'usb-storage,bus=usb-bus0.0,port=1,drive=drive-disk-bootloader,id=usb-disk-bootloader,bootindex=1,removable=on'"
else
	# Use bootloader as first sata disk
	KVM_SYNOBOOT="${KVM_SYNOBOOT} -device 'ide-hd,bus=ahci0.${i_sata},drive=drive-disk-bootloader,id=sata-disk-bootloader,bootindex=1'"
	((++i_sata))
fi

# Add SATA disks
# ######################################
log "INFO" "Adding vm disk(s)  ..."
TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS}"
fpath_diskname_=""
diskformat_=""

i=0
i_scsi=0
_tmpDevName="null"
for size in $DISK_SIZE ; do
	if [[ $size == "/dev/"* ]] && [[ -e "$size" ]]; then
		log "INFO" "... adding full device : $size"
		fpath_diskname_="$size"
		diskformat_="raw"
	elif [[ ${size%[Gg]} =~ ^[0-9]+$ ]]; then
		diskformat_="${DISK_FORMAT}"
		fpath_diskname_="${DISK_PATH%/}/vm-disk-data${i}.${diskformat_}"
		if [[ ! -f ${fpath_diskname_} ]]; then
			qemu-img create -f ${DISK_FORMAT} ${fpath_diskname_} ${size%[Gg]}G \
				&& log "INFO" "... SUCCESS: ${DISK_FORMAT} disk created: ${fpath_diskname_}" \
				|| (log "ERROR" "... FAILED: Cannot create disk" && exit 13)
		else
			log "INFO" "... SKIP: ${DISK_FORMAT} disk already exists: ${fpath_diskname_}"
		fi
		((++i))
	else
		log "ERROR" "... ARG: invalid argument : $size"	
		exit 30
	fi
	
	if [[ "${VM_ENABLE_VIRTIO_SCSI}" == [YySs12]* ]]; then
		if [[ "${VM_ENABLE_VIRTIO_SCSI}" == [Ss2]* ]] || [[ ${i_scsi} -eq 0 ]]; then
			_tmpDevName="scsihw${i_scsi}"
			TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'virtio-scsi-pci,id=${_tmpDevName},bus=pcie.0,addr=0x$( printf "%02x\n" "$(( i_scsi+24 ))" )'"
		fi
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -drive 'file=${fpath_diskname_},if=none,id=drive-scsi${i_scsi},format=${diskformat_}${DISK_OPTS_DRV}'"
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'scsi-hd,bus=${_tmpDevName}.0,channel=0,scsi-id=0,lun=${i_scsi},drive=drive-scsi${i_scsi},id=scsi${i_scsi}${DISK_OPTS_DEV}'"
		
		# TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'nvme,drive=drive-scsi${i_scsi},serial=nvme-${i_scsi},id=nvme${i_scsi}'"
		# serial=VH000${i_scsi}
		((++i_scsi))
	else
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -drive 'file=${fpath_diskname_},if=none,id=drive-sata${i_sata},format=${diskformat_}${DISK_OPTS_DRV}'"
		TMP_KVM_BLK_OPTS="${TMP_KVM_BLK_OPTS} -device 'ide-hd,bus=ahci0.${i_sata},drive=drive-sata${i_sata},id=sata${i_sata}${DISK_OPTS_DEV}'"
		((++i_sata))
	fi
done
: ${KVM_BLK_OPTS:="${TMP_KVM_BLK_OPTS}"}

# Set Qemu option
# ######################################
: ${KVM_OPTS:="\
  -machine q35 \
  -nodefaults \
  -overcommit mem-lock=off \
  -msg timestamp=on \
  -chardev pty,id=charserial0 \
  -device isa-serial,chardev=charserial0,id=serial0 \
  -serial mon:stdio \
  -monitor unix:/run/qemu-monitor.sock,server,nowait \
  -pidfile /run/qemu.pid \
  "}
  # Removed readconfig but keep file
  # because re-addressing pcie.0 device with addr option 
  # -readconfig /qemu_cfg/pve-q35-4.0.cfg

[[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]] && KVM_OPTS="${KVM_OPTS} -device 'virtio-balloon-pci,id=balloon0,bus=pcie.0,addr=0x2'"

# Set Qemu CPU and RAM
# ######################################
SMP=$(($CORES*$THREADS))
: ${KVM_CPU_OPTS:="-m $RAM -cpu ${CPU} -smp $SMP,sockets=1,cores=$CORES,threads=$THREADS"}

# Set 9p
# ######################################
: ${KVM_9P:=""}
if [[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]] && [[ "${VM_ENABLE_9P}" == [Yy1]* ]] && [[ "x${VM_9P_PATH}" != "x" ]]; then 
	log "INFO" "Adding 9p sharefolders ..."

	i=0
	for path_ in $VM_9P_PATH ; do
		log "INFO" "... path=${path_} , mount_tag=hostdata${i}"
		KVM_9P="${KVM_9P} -fsdev ${VM_9P_OPTS},id=fsdev-fs${i},path=${path_} -device virtio-9p-pci,id=fs${i},fsdev=fsdev-fs${i},mount_tag=hostdata${i},bus=pcie.0"
		((++i))
	done
fi

# Enable KVM support only if the host supports it
# ######################################
if [[ $(grep -e vmx -e svm /proc/cpuinfo) ]]; then
  log "INFO" "KVM acceleration enabled"
  KVM_OPTS="$KVM_OPTS -enable-kvm -machine accel=kvm,usb=off "
else
  log "WARNING" "KVM acceleration disabled"
  #exit -20
fi

# Set Qemu graphics & vnc 
# ######################################
if [[ "$VM_ENABLE_VGA" == [Yy1]* ]]; then
  : ${KVM_VIDEO_OPTS:="-vga qxl -vnc 0.0.0.0:0 -k en-us"}
else
  : ${KVM_VIDEO_OPTS:="-nographic"}
fi

# Configure Network
# ######################################
log "INFO" "Configuring network ..."
#DEFAULT_ROUTE=$(ip route | grep default | awk '{print $3}')

if [[ "x${VM_NET_TAP}" == "x" ]]; then
	if [[ "${VM_NET_DHCP}" == [Yy1]* ]]; then
		VM_NET_TAP="_VmMacvtap"
		log "INFO" "... to retrieve IP via DHCP through Macvtap (${VM_NET_TAP}) and MAC: ${VM_NET_MAC}"
		
		ip l add link eth0 name ${VM_NET_TAP} address ${VM_NET_MAC} type macvtap mode bridge || true
		ip l set ${VM_NET_TAP} up
		
		ip a flush eth0
		ip a flush ${VM_NET_TAP}
		
		_DhcpIP=$( dhclient -v ${VM_NET_TAP} 2>&1 | grep ^bound | cut -d' ' -f3 )
		[[ "${_DhcpIP}" == [0-9.]* ]] \
		&& log "INFO" "... Retrieve IP: ${_DhcpIP} from DHCP with MAC: ${VM_NET_MAC}" \
		|| ( log "ERROR" "... Cannot retrieve IP from DHCP with MAC: ${VM_NET_MAC}" && exit 14 )

		ip a flush ${VM_NET_TAP}
		
		_tmpTapPath="/dev/tap$(</sys/class/net/${VM_NET_TAP}/ifindex)"
		# get MAJOR MINOR DEVNAME
		MAJOR=""
		eval "$(</sys/class/net/${VM_NET_TAP}/macvtap/${_tmpTapPath##*/}/uevent) _tmp=0"
		
		[[ "x${MAJOR}" != "x" ]] \
			&& log "INFO" "... PLEASE MAKE SURE, Docker run command line used: --device-cgroup-rule='c ${MAJOR}:* rwm'" \
			|| ( log "ERROR" "... macvtap creation issue: Cannot find: /sys/class/net/${VM_NET_TAP}/" && exit 15 )
		
		[[ ! -e ${_tmpTapPath} ]] && [[ -e /dev0/${_tmpTapPath##*/} ]] && ln -s /dev0/${_tmpTapPath##*/} ${_tmpTapPath}
		
		if [[ ! -e ${_tmpTapPath} ]]; then
			log "WARNING" "... file does not exist: ${_tmpTapPath}"
			mknod ${_tmpTapPath} c $MAJOR $MINOR \
				&& log "INFO" "... File created with mknod: ${_tmpTapPath}" \
				|| ( log "ERROR" "... Cannot mknod: ${_tmpTapPath}" && exit 16 )
		fi
		KVM_NET_OPTS="-netdev tap,id=hostnet0,vhost=on,vhostfd=40,fd=30 30<>${_tmpTapPath} 40<>/dev/vhost-net"
	else
		VM_NET_TAP="_VmNatTap"
		log "INFO" "... NAT Network (${VM_NET_TAP}) to ${VM_NET_IP}"
		configureNatNetworks
		KVM_NET_OPTS="-netdev tap,ifname=${VM_NET_TAP},script=no,downscript=no,id=hostnet0"
		
		# Build DNS options from container /etc/resolv.conf
		nameservers=($(grep '^nameserver' /etc/resolv.conf | sed 's/nameserver //'))
		searchdomains=$(grep '^search' /etc/resolv.conf | sed 's/search //' | sed 's/ /,/g')
		domainname=$(echo $searchdomains | awk -F"," '{print $1}')

		for nameserver in "${nameservers[@]}"; do
		  [[ -z $DNS_SERVERS ]] && DNS_SERVERS=$nameserver || DNS_SERVERS="$DNS_SERVERS,$nameserver"
		done
		DNSMASQ_OPTS="$DNSMASQ_OPTS                         \
		  --dhcp-option=option:dns-server,$DNS_SERVERS      \
		  --dhcp-option=option:router,${VM_NET_IP%.*}.1         \
		  --dhcp-option=option:domain-search,$searchdomains \
		  --dhcp-option=option:domain-name,$domainname      \
		  "
		[[ -z $(hostname -d) ]] || DNSMASQ_OPTS="$DNSMASQ_OPTS --dhcp-option=option:domain-name,$(hostname -d)"

		log "INFO" "... Lauching dnsmasq"
		log "DEBUG" "dnsmasq options: $DNSMASQ_OPTS"
		$DNSMASQ $DNSMASQ_OPTS
	fi
else
	log "INFO" "... No configuration, just using tuntap : ${VM_NET_TAP}"
	KVM_NET_OPTS="-netdev tap,ifname=${VM_NET_TAP},script=no,downscript=no,id=hostnet0"
fi

#KVM_NET_OPTS="-netdev user,hostfwd=tcp:127.0.0.1:5000-:5000"
[[ "${VM_ENABLE_VIRTIO}" == [Yy1]* ]] \
	&& KVM_NET_OPTS="${KVM_NET_OPTS} -device virtio-net-pci,netdev=hostnet0,mac=${VM_NET_MAC},id=net0" \
	|| KVM_NET_OPTS="${KVM_NET_OPTS} -device e1000e,netdev=hostnet0,mac=${VM_NET_MAC},id=net0"


# Hack for guest VMs complaining about "bad udp checksums in 5 packets"
log "INFO" "Hack for guest VMs complaining about: bad udp checksums in 5 packets"
iptables -A POSTROUTING -t mangle -p udp --dport bootpc -j CHECKSUM --checksum-fill \
        || ( log "WARNING" "Iptables hack for checksum FAILED" && ethtool -K eth0 tx off || true )

if [[ "x${VM_CUSTOM_CODE}" != "x" ]]; then
	log "INFO" "Running custom code ..."
	log "INFO" "... ${VM_CUSTOM_CODE}"
	eval ${VM_CUSTOM_CODE}
fi

[[ "x${MAJOR}" != "x" ]] && log "INFO" "PLEASE MAKE SURE, Docker is using the following option otherwise you may have permission issue on ${_tmpTapPath} file: --device-cgroup-rule='c ${MAJOR}:* rwm' "
[[ "${_DhcpIP}" == [0-9.]* ]] && log "INFO" "You should access your DSM with: http://${_DhcpIP}:5000"

log "INFO" "Pause for ${VM_CUSTOM_BOOTWAIT}s, please wait ..."
sleep ${VM_CUSTOM_BOOTWAIT}

# Launching Qemu VM command
# ######################################
log "INFO" "Launching qemu-kvm ..."
COMMAND="$LAUNCHER ${KVM_OPTS} ${KVM_PREBOOT} ${KVM_SYNOBOOT} ${KVM_BLK_OPTS} ${KVM_VIDEO_OPTS} ${KVM_CPU_OPTS} ${KVM_NET_OPTS} ${KVM_9P} ${VM_CUSTOM_OPTS}"
log "DEBUG" "${COMMAND}"
trap '/usr/bin/vm-power-down' SIGTERM
trap '/usr/bin/vm-power-down' SIGINT
eval ${COMMAND}
